import numpy as np
import struct

from tqdm import tqdm


def float16_to_hex4(value: float) -> list[str]:
    """
    将一个浮点数转换为 IEEE 754 半精度浮点数 (float16)，
    并输出 4 个 16 进制字符串（每个2位）。
    """
    # 转换为float16
    f16 = np.float16(value)

    # 获取16位无符号整数表示
    bits = f16.view(np.uint16)

    # 拆分成4个十六进制字符串（每个代表4位）
    hex_list = [f"{(bits >> shift) & 0xF:X}".lower() for shift in (12, 8, 4, 0)]

    return hex_list


def hex4_to_float16(hexStr) -> float:
    """
    将4个16进制字符串（每个1位，合起来16位）
    转换为IEEE 754半精度浮点数，并返回float值。
    例如: ['3','c','0','0'] -> 1.0
    """
    if len(hexStr) != 4:
        raise ValueError("必须传入4个16进制字符串")

    # 拼接成完整的16位十六进制
    bits = int(hexStr, 16)  # 转换为整数

    # 转换为float16，再转为Python float
    f16 = np.uint16(bits).view(np.float16)
    return float(f16)


def hex_to_float(hex_str):
    """将8位16进制字符串转为IEEE754单精度浮点数"""
    # 转成 int，再转成4字节
    i = int(hex_str, 16)
    b = i.to_bytes(4, byteorder='big')  # 假设大端（常见存储方式）
    return struct.unpack('!f', b)[0]  # ! 表示network(big-endian)

def float_to_hex(f):
    """将IEEE754单精度浮点数转为8位16进制字符串"""
    b = struct.pack('!f', f)            # ! 表示 big-endian，4字节
    return b.hex()


# ---------------- 工具函数 ----------------
def load_weights(filename, shape):
    """从txt文件加载权重并reshape"""
    with open(filename, "r") as f:
        data = f.read().split()
    data = [hex4_to_float16(x[i:i + 4]) for x in data for i in range(0, len(x), 4)]
    weights = np.array([float(x) for x in data])
    return weights.reshape(shape)


def load_weights32(filename, shape):
    """从txt文件加载权重并reshape"""
    with open(filename, "r") as f:
        data = f.read().split()
    data = [hex_to_float(x) for x in data]
    weights = np.array([float(x) for x in data])
    return weights.reshape(shape)


def hex_to_image(hex_list):
    """4096个16进制字符串 -> 32x32灰度图 (范围0-1)"""
    arr = np.array(hex_list, dtype=np.float32)
    arr = arr.reshape(32, 32)
    return arr[np.newaxis, :, :]  # shape (1,32,32)


def relu(x):
    return np.maximum(0, x)


def conv2d(x, w, stride=1, padding=0):
    """
    x: (C_in, H, W)
    w: (C_out, C_in, kH, kW)
    """
    C_in, H, W = x.shape
    C_out, _, kH, kW = w.shape

    H_out = (H + 2 * padding - kH) // stride + 1
    W_out = (W + 2 * padding - kW) // stride + 1

    out = np.zeros((C_out, H_out, W_out))

    x_padded = np.pad(x, ((0, 0), (padding, padding), (padding, padding)), mode="constant")

    for co in range(C_out):
        for h in range(H_out):
            for ww in range(W_out):
                hs, ws = h * stride, ww * stride
                region = x_padded[:, hs:hs + kH, ws:ws + kW]
                out[co, h, ww] = np.sum(region * w[co])
    return out


def maxpool2d(x, size=2, stride=2):
    C, H, W = x.shape
    H_out, W_out = H // stride, W // stride
    out = np.zeros((C, H_out, W_out))
    for c in range(C):
        for h in range(H_out):
            for w in range(W_out):
                hs, ws = h * stride, w * stride
                out[c, h, w] = np.max(x[c, hs:hs + size, ws:ws + size])
    return out


def linear(x, W):
    return np.dot(x.T, W)


# ---------------- 加载权重 ----------------
conv1_w = load_weights("./distilled/conv1_hex.txt", (6, 1, 5, 5))  # 6个5x5卷积核
# conv1_b = load_bias("conv1.txt", 6)

conv2_w = load_weights("./distilled/conv2_hex.txt", (16, 6, 5, 5))
# conv2_b = load_bias("conv2.txt", 16)

conv3_w = load_weights("./distilled/conv3_hex.txt", (32, 16, 3, 3))
# conv3_b = load_bias("conv3.txt", 32)

fc1_w = load_weights32("./distilled/fc1_hex.txt", (288, 120))
# fc1_b = load_bias("fc1.txt", 120)

fc2_w = load_weights32("./distilled/fc2_hex.txt", (120, 120))
# fc2_b = load_bias("fc2.txt", 120)

fc3_w = load_weights32("./distilled/fc3_hex.txt", (120, 84))
# fc3_b = load_bias("fc3.txt", 84)

fc4_w = load_weights32("./distilled/fc4_hex.txt", (84, 10))


# fc4_b = load_bias("fc4.txt", 10)


# ---------------- 推理函数 ----------------
def predict(hex_list):
    x = hex_to_image(hex_list)

    # Conv1 -> ReLU -> Pool
    x = relu(conv2d(x, conv1_w, padding=2))
    x = maxpool2d(x)

    # Conv2 -> ReLU -> Pool
    x = relu(conv2d(x, conv2_w))
    x = maxpool2d(x)

    # Conv3 -> ReLU
    x = relu(conv2d(x, conv3_w,padding=1))
    x = maxpool2d(x)

    # Flatten
    x = x.flatten()

    # x = hex_list

    # FC1 -> ReLU
    x = relu(linear(x, fc1_w))

    # FC2 -> ReLU
    x = relu(linear(x, fc2_w))

    # FC3 -> ReLU
    x = relu(linear(x, fc3_w))

    # FC4 -> Softmax
    x = linear(x, fc4_w)
    # probs = softmax(x)

    return np.argmax(x), x


# ---------------- 示例 ----------------
if __name__ == "__main__":
    # correct = 0
    # with open('./test_images_hex.txt', 'r') as f:
    #     images = f.readlines()
    # images = [x.replace('\n', '') for x in images]
    # with open('./test_labels.txt', 'r') as f:
    #     labels = f.readlines()
    # labels = [int(x.replace('\n', '')) for x in labels]
    # for ima, glab in tqdm(zip(images, labels)):
    #     hex_list = [hex4_to_float16(ima[i:i + 4]) for i in range(0, len(ima), 4)]
    #     label, probs = predict(hex_list)
    #     if label == glab:
    #         correct += 1
    # print(correct / len(images))
    example = '3a06384c378836763606371738cd37f8351534e534b534a535053545356535d63596351536f738ad38743545326632a732463266332735453666344431c63105379836663646361635d63788392d38643697359634d535d63687373736f736b7359635963777389d388d3616349533a8320632663485364636163327310530e536c736b736563676361637f838fd389d387c3788374738ad390d398e3905389536563707381c3824382437f8369735a632c7338835e6360634b531a630a5302437673727372737e8386438c538d5389d388d383c389d39753a0639ce392538dd37d8381c37573596363636f73697362634c5345435f6351532c7310530a530043864380437e8387c38a53885380437c837b83804385c396d39a6391538d53885383438343687351534a535153515351535d635d63535328730e530853024302438d5384c38043834381c380436763586355536363687384c389d382c38043798370737c836e7345432e732c7330732a73596362634c531a6306430442f88300437f8382437e83757372736b7350533c8348535253586367636f7368735e6354535d6382c36b734043226316530e5322635b636463596334730042f472f882f47363635c6366635e635b634d534043347340434b5356535e6364635c6356534c536b7383c363633c831c630a530e53287352536063565334730042fc82fc82ec73525345434c53575353533a832a732c733673454354535b63525350534c5351536e7379835d632c73125302430a531053388350535353414304430243024302434a5338833c83515352533673186320632a7341434d5350533a8341434543485375737883525328731653064308530e531863367352534443125308530e530a533e832263307353534f532663165320632e7348534c53495338833883404347436a736e7353532e731e630e5308530c530e53186341434a534343327341433a832e731e632e7351534c53206314532463327344434a534b53414336732e7330736463804372735a634d531c630e530e5310530e530e533a835353525355535753347332734d53596351533073246334733c8345434b53454338832a7322632e73656379836e736a73697349531e6314530c53044306432a7354534e5343434c5351535653606366636063545343434f534e534a534c5344432a731a631863414375736e734b535653676363633c831a6314530a530c533e834c53246312532a7368736663606361636563636363636d735e63505347432c73186312531453515385c37d83434332735c6375736163525347432663145349533c830a5308531253687367634c53474362636b736f73798370735d633e832a731e6312532a736363834387c35a633a8362637c8374736a735a6340432e734d5348531c630643004363635053367332734f536d736e7378837c836163367320633a832a734b536e7376737b836c7366636f735e63656376736463485326634b5354534643145306436763444328732c733c834f5358637073767357532a73246352534e535f6372735d6349535353646353534143464353534a53535345434d53515347431c6308536d735353226324632263266340436063687352533c83414364636a73676360634d5336732a733e833e832a732c733a8330734f5350534c53434314531253105366635b63206314531453145320634a535e6362635e6361636d736e735c6353534b534243367330732663266330733c83404355534c5343433e83186314531c6368735b6324630c5306431053125334735f63636353534d536873747366635453404340433e8324631c632a7338834e535c63596346433073454338831a632873767369734143105306430e531253388360635c63327328735b637e8372735553414332734853307324632a73307341434d533e8320631453434346432063307373736f7349531a630e530e5326635153636349531a631e63535386c37a834f534a5351536463444330731863206328731e630e530c530a5340434e53434347436b7363635453266322632e735253687356531a630e53165340438143824355534d53798368735153434324631c63145310530c530a530a532063414355535b636163565357534c5353535c6364636163307304430a530e534243804387c352536b7389536d735253464342432e731253044306430a530e53125330734e53565358634f534c535d636d736b73626342430a530643085314534c5381c387c36b73804378834f533c83367338832c730e5308531c63367334733073444340433c834e534e534343545368735f6347432063105306430e5322634643777384c37f837e8373734f532c732c73388330730c530a5316534443535356534e533e832a7343434c533e8346435c633e8320631e630e530e53165320633a835d637e83777378837773666349532a73485342430e530c5310531a633a835963555347431e6334734a533883404355532e73105312530a53105310531253226349537273676361635653666362634d535553464334732463165312533673565343434d532a7338834d533e83307355533e8302430a530a530c530e531653145344435b63404336733a83525361635a635863525354534f53444336734e5350532463464332732663454342432a7359634e531053125320632063246322633c8364634a53125314531a6340435b635f634c534a53444349534a53515352533673165340433c8318631e634b533273555359631863125334733c8342434f5373737e833c830a5312531653424361635e63347338831e63145318633c8352532a7310532c73424'
    hex_list = [hex4_to_float16(example[i:i + 4]) for i in range(0, len(example), 4)]
    label, probs = predict(hex_list)
    pass
    # ft = '3800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003d66e000380000003800000038000000380000003e37e0003d212000380000003c6d00003800000038000000380000003800000038000000380000003db7a00038000000380000003800000038000000380000003e58c00038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003c8580003ea1a000380000003e4b4000380000003da1200038000000380000003db7400038000000380000003d1a800038000000380000003e89e0003ec620003de7a0003ee2a0003e6dc0003d87c0003df8e0003d2000003e4720003e3be00038000000380000003d6420003d8620003800000038000000380000003e1420003d80200038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003e0480003d12e0003e87c0003e45a0003e9d40003e5fe0003e7080003e1bc0003e2700003e8dc0003e1460003d4400003800000038000000380000003d83c0003eaaa0003d4f40003d69c00038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003d64800038000000380000003800000038000000380000003800000038000000380000003deb60003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003dfe200038000000380000003d8d000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003e4400003e83c0003ed200003eb8a0003e9520003f2740003e7c80003f0320003e88a00038000000380000003cda000038000000380000003e5ca00038000000380000003c87800038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003ede2000380000003e5080003da9c00038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003e07c0003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003de300003e21c0003de880003e6f80003e7d80003e5d80003e3580003ecd80003d2240003cfac0003da7e0003efc4000380000003dc8c00038000000380000003e3080003dce60003e0de0003d55c00038000000380000003e89a00038000000380000003800000038000000'
    # ft = [hex_to_float(ft[i:i + 8]) for i in range(0, len(ft), 8)]
    # ft = np.array(ft, dtype=np.float32)
    # idx, res = predict(ft)
    # pass
