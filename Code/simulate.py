import numpy as np
import struct

from tqdm import tqdm


def float16_to_hex4(value: float) -> str:
    """
    将一个浮点数转换为 IEEE 754 半精度浮点数 (float16)，
    并输出 4 个 16 进制字符串（每个2位）。
    """
    # 转换为float16
    f16 = np.float16(value)

    # 获取16位无符号整数表示
    bits = f16.view(np.uint16)

    # 拆分成4个十六进制字符串（每个代表4位）
    hex_list = [f"{(bits >> shift) & 0xF:X}".lower() for shift in (12, 8, 4, 0)]

    hex_str = "".join(hex_list)
    return hex_str


def hex4_to_float16(hexStr) -> float:
    """
    将4个16进制字符串（每个1位，合起来16位）
    转换为IEEE 754半精度浮点数，并返回float值。
    例如: ['3','c','0','0'] -> 1.0
    """
    if len(hexStr) != 4:
        raise ValueError("必须传入4个16进制字符串")

    # 拼接成完整的16位十六进制
    bits = int(hexStr, 16)  # 转换为整数

    # 转换为float16，再转为Python float
    f16 = np.uint16(bits).view(np.float16)
    return float(f16)


def hex_to_float(hex_str):
    """将8位16进制字符串转为IEEE754单精度浮点数"""
    # 转成 int，再转成4字节
    i = int(hex_str, 16)
    b = i.to_bytes(4, byteorder='big')  # 假设大端（常见存储方式）
    return struct.unpack('!f', b)[0]  # ! 表示network(big-endian)

def float_to_hex(f):
    """将IEEE754单精度浮点数转为8位16进制字符串"""
    b = struct.pack('!f', f)            # ! 表示 big-endian，4字节
    return b.hex()


# ---------------- 工具函数 ----------------
def load_weights(filename, shape):
    """从txt文件加载权重并reshape"""
    with open(filename, "r") as f:
        data = f.read().split()
    data = [hex4_to_float16(x[i:i + 4]) for x in data for i in range(0, len(x), 4)]
    weights = np.array([float(x) for x in data])
    return weights.reshape(shape)


def load_weights32(filename, shape):
    """从txt文件加载权重并reshape"""
    with open(filename, "r") as f:
        data = f.read().split()
    data = [hex_to_float(x) for x in data]
    weights = np.array([float(x) for x in data])
    return weights.reshape(shape)


def hex_to_image(hex_list):
    """4096个16进制字符串 -> 32x32灰度图 (范围0-1)"""
    arr = np.array(hex_list, dtype=np.float32)
    arr = arr.reshape(32, 32)
    return arr[np.newaxis, :, :]  # shape (1,32,32)


def relu(x):
    return np.maximum(0, x)


def conv2d(x, w, stride=1, padding=0):
    """
    x: (C_in, H, W)
    w: (C_out, C_in, kH, kW)
    """
    C_in, H, W = x.shape
    C_out, _, kH, kW = w.shape

    H_out = (H + 2 * padding - kH) // stride + 1
    W_out = (W + 2 * padding - kW) // stride + 1

    out = np.zeros((C_out, H_out, W_out))

    x_padded = np.pad(x, ((0, 0), (padding, padding), (padding, padding)), mode="constant")

    for co in range(C_out):
        for h in range(H_out):
            for ww in range(W_out):
                hs, ws = h * stride, ww * stride
                region = x_padded[:, hs:hs + kH, ws:ws + kW]
                out[co, h, ww] = np.sum(region * w[co])
    return out


def maxpool2d(x, size=2, stride=2):
    C, H, W = x.shape
    H_out, W_out = H // stride, W // stride
    out = np.zeros((C, H_out, W_out))
    for c in range(C):
        for h in range(H_out):
            for w in range(W_out):
                hs, ws = h * stride, w * stride
                out[c, h, w] = np.max(x[c, hs:hs + size, ws:ws + size])
    return out


def linear(x, W):
    return np.dot(x.T, W)


# ---------------- 加载权重 ----------------
conv1_w = load_weights("./distilled/conv1_hex.txt", (6, 1, 5, 5))  # 6个5x5卷积核
# conv1_b = load_bias("conv1.txt", 6)

conv2_w = load_weights("./distilled/conv2_hex.txt", (16, 6, 5, 5))
# conv2_b = load_bias("conv2.txt", 16)

conv3_w = load_weights("./distilled/conv3_hex.txt", (32, 16, 3, 3))
# conv3_b = load_bias("conv3.txt", 32)

fc1_w = load_weights32("./distilled/fc1_hex.txt", (288, 120))
# fc1_b = load_bias("fc1.txt", 120)

fc2_w = load_weights32("./distilled/fc2_hex.txt", (120, 120))
# fc2_b = load_bias("fc2.txt", 120)

fc3_w = load_weights32("./distilled/fc3_hex.txt", (120, 84))
# fc3_b = load_bias("fc3.txt", 84)

fc4_w = load_weights32("./distilled/fc4_hex.txt", (84, 10))


# fc4_b = load_bias("fc4.txt", 10)


# ---------------- 推理函数 ----------------
def predict(hex_list):
    x = hex_to_image(hex_list)

    # Conv1 -> ReLU -> Pool
    x = relu(conv2d(x, conv1_w, padding=2))
    x = maxpool2d(x)

    # Conv2 -> ReLU -> Pool
    x = relu(conv2d(x, conv2_w))
    x = maxpool2d(x)

    # Conv3 -> ReLU
    x = relu(conv2d(x, conv3_w,padding=1))
    x = maxpool2d(x)

    # Flatten
    x = x.flatten()

    # x = hex_list

    # FC1 -> ReLU
    x = relu(linear(x, fc1_w))

    # FC2 -> ReLU
    x = relu(linear(x, fc2_w))

    # FC3 -> ReLU
    x = relu(linear(x, fc3_w))

    # FC4 -> Softmax
    x = linear(x, fc4_w)
    # probs = softmax(x)

    return np.argmax(x), x


# ---------------- 示例 ----------------
if __name__ == "__main__":
    # correct = 0
    # with open('./test_images_hex.txt', 'r') as f:
    #     images = f.readlines()
    # images = [x.replace('\n', '') for x in images]
    # with open('./test_labels.txt', 'r') as f:
    #     labels = f.readlines()
    # labels = [int(x.replace('\n', '')) for x in labels]
    # for ima, glab in tqdm(zip(images, labels)):
    #     hex_list = [hex4_to_float16(ima[i:i + 4]) for i in range(0, len(ima), 4)]
    #     label, probs = predict(hex_list)
    #     if label == glab:
    #         correct += 1
    # print(correct / len(images))
    example = '33883525368736f735e633272f472c04298628042a872c852d862e87300431a633a834e53586358634d534743404324630642ec72ec730e534143606377737673676370737a837d83727351531652c4425052004200424042505260629052c442f47314533273454341434443505359634e5332730e52f472f88310532a73414377737983777379837e83788359631862a87240422062606270724042004240428852c442fc8326634443575367636c7368736c736d7362634c531a62f072e4636d73656366636f737c8385c3854369733882ec72a062707240420041c041c04200427072cc530c5342435e6363634e53307342435653666371736b735d634f536c736763717381c386c387438b5388d3788355532e72fc82b88288525052206240428852d053186350536b73697347430642e062f073165348536c7380c380437c8385c387c38b538fd38d538a538ad38b53864379835a633e831e630c52fc83004302430e533e8365637a837a836a73505338831e6318632c73535372737f8388d390538d53874383c37c83798384438d538fd38dd3854379836d7363635b635e63616363636d737f8384c383437c837073505324630a531e634a536873767390d391d388536d73485324632e735653788386438d538bd388d3874386c3834385c388d388d388538a538a5386c380c371734442f472a062c043044347435f6395d3925383c354530442b882c042f8832e735a6381438b538cd38c538d538ad389538ad38dd38c538dd387c381c37e8371734c531c62f472c042986306434443975396538c5363630852a0629052b072dc631e63616384c38c538cd38ed38d53895389538a5383437983656353534d5354535453555351533e8310531e63474399e39ce392d37c834c530042c442cc52e873125352537c8389538dd392d391538d538dd387435d6334731252fc82e873044320634743616371736c7369736b7399e39ae3965390d38543565338833a8347434d53626380c38b538ed38ed38ed38f538cd37a833a82ec72c042986280429862cc5304433883646381c3854380c397d394d394d3986396538a53824380c3814380c3834387438ad388d3814382438a53874363631a62cc5290526062206240428042a062dc6328735c6377737b8392d38c538d5390538ed38a5384c3834382c382c38743885386c380c37073737385c388536c732462c442707240420042004240427072b072fc8345436b7377738d53834376736a735f635a63525355535863575364636c73747375736e73757388538fd380c33a82d05260622062004200425052b8830243367359637173757382c3606342431e630e53105316531a631653165328733e834c5352535553676385c38f5383434c52f472804200422062b073024338835a6370737d837f83727368733072f472d452c442c042d052d452d052e062f8830c531a6322632e734b53737385c382c36a7343430a52e0630243434362637773844389538a53864377735e631a62c442804260624042707270728042a062c442d452f07306430e533a83687384c389d3885380c371736c73757381c3864388538743854389d388d382c37b834c52ec724041c0420042004200420042404260628852c442e8730c534853757388d38cd390d39253935393d393538fd38e538ed38a53814385c3895388d37c83747354531e62cc5220600000000000000002004200427072e4633473656384438853844387438f5392d3935393d39553965394538e5388d387438a538bd35b636c7380437e835f633272fc82c4429052707250527072b073044349537883895387437f8382438bd390d390538e538d538bd3895386c384c381c388d38e5363635d63707381c382c380436f7364635453367326633e8344434c536c7385c38cd38bd3885387c385c3824376736163515349534a534e5351535753717384436c73505340434043485359637573864387c380c37c838143824383c38b538b538ad38b5388d37b8359633e831862f882e062cc52cc52d862e8730443206343436f734c530a52b882a872d053186343435d637883844387c389d38bd38e538b538b5388d3798349530a52d052b0729862707250524042606280429862a872d0537f836873454304429052404250528852cc531c635a6376737f838143854386c38b5386435f630a52a062a062a87288524042206220622062505240426062c0437273788373735d633672f882c852905260629862f47328734c53626372737b83874386c36a733072d862a87298627072004200420042206250528852d8631e63495367637983804378835a63464332731c630442b882a8730243424365637b8386438bd38b537d8346430a52d862a0628852a062e0630243004322634d53697310534b536f738343854382437f837b83747364634b53404332733a835863788382c38543895387c37a836c7358634143434346435963697365636b737273747322634c536b7381c3874388538a5389d388d38a538d538b5382c37173687373737a837b837983767372737473717365635d63565354535653586356534e53485359636d737b8382c3874388d385c378836c7372737f8385c389d387c380c37c83788377737373636346432c731a630642ec72e062d452d052e062f472f072e8737e83824385438643874386c373734a53165300430a53206340434853434343434743535361635f6343430c52c8526062505250522062004240428042885280438bd3895386c385c3854383c36f734342f472b882a87298628852804280428852a872e46322634b53505344431a62d45288524041c041c041c04200422062206'
    hex_list = [hex4_to_float16(example[i:i + 4]) for i in range(0, len(example), 4)]
    label, probs = predict(hex_list)
    pass
    # ft = '3800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003d66e000380000003800000038000000380000003e37e0003d212000380000003c6d00003800000038000000380000003800000038000000380000003db7a00038000000380000003800000038000000380000003e58c00038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003c8580003ea1a000380000003e4b4000380000003da1200038000000380000003db7400038000000380000003d1a800038000000380000003e89e0003ec620003de7a0003ee2a0003e6dc0003d87c0003df8e0003d2000003e4720003e3be00038000000380000003d6420003d8620003800000038000000380000003e1420003d80200038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003e0480003d12e0003e87c0003e45a0003e9d40003e5fe0003e7080003e1bc0003e2700003e8dc0003e1460003d4400003800000038000000380000003d83c0003eaaa0003d4f40003d69c00038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003d64800038000000380000003800000038000000380000003800000038000000380000003deb60003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003dfe200038000000380000003d8d000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003e4400003e83c0003ed200003eb8a0003e9520003f2740003e7c80003f0320003e88a00038000000380000003cda000038000000380000003e5ca00038000000380000003c87800038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003ede2000380000003e5080003da9c00038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003e07c0003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003800000038000000380000003de300003e21c0003de880003e6f80003e7d80003e5d80003e3580003ecd80003d2240003cfac0003da7e0003efc4000380000003dc8c00038000000380000003e3080003dce60003e0de0003d55c00038000000380000003e89a00038000000380000003800000038000000'
    # ft = [hex_to_float(ft[i:i + 8]) for i in range(0, len(ft), 8)]
    # ft = np.array(ft, dtype=np.float32)
    # idx, res = predict(ft)
    # pass
